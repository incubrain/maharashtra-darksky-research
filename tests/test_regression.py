"""
Regression tests with golden files.

Compares pipeline outputs against known-good reference data to detect
unintentional changes in numerical results. Golden files are stored
in tests/golden/ and generated by running this module with --update-golden.

To update golden files after an intentional change:
    pytest tests/test_regression.py --update-golden

Any change to trend coefficients, classification boundaries, or
sky brightness conversions will be caught here.
"""

import os
import json

import numpy as np
import pandas as pd
import pytest

from src.formulas.classification import classify_alan, classify_alan_series
from src.formulas.trend import fit_log_linear_trend
from src.formulas.sky_brightness import (
    NATURAL_SKY_BRIGHTNESS,
    RADIANCE_TO_MCD,
    REFERENCE_MCD,
    BORTLE_THRESHOLDS,
)

GOLDEN_DIR = os.path.join(os.path.dirname(__file__), "golden")


@pytest.fixture
def update_golden(request):
    return request.config.getoption("update_golden", default=False)


# ── Helper Functions ─────────────────────────────────────────────────


def _golden_path(name):
    return os.path.join(GOLDEN_DIR, name)


def _save_golden_csv(df, name):
    os.makedirs(GOLDEN_DIR, exist_ok=True)
    df.to_csv(_golden_path(name), index=False)


def _save_golden_json(data, name):
    os.makedirs(GOLDEN_DIR, exist_ok=True)
    with open(_golden_path(name), "w") as f:
        json.dump(data, f, indent=2, default=str)


def _load_golden_csv(name):
    path = _golden_path(name)
    if not os.path.exists(path):
        pytest.skip(f"Golden file {name} not found. Run with --update-golden first.")
    return pd.read_csv(path)


def _load_golden_json(name):
    path = _golden_path(name)
    if not os.path.exists(path):
        pytest.skip(f"Golden file {name} not found. Run with --update-golden first.")
    with open(path) as f:
        return json.load(f)


# ── Synthetic Test Data (deterministic) ──────────────────────────────


def _make_synthetic_yearly():
    """Create deterministic synthetic yearly data for regression testing."""
    rng = np.random.default_rng(42)
    years = list(range(2012, 2025))
    rows = []
    districts = {
        "DistrictA": {"base": 2.0, "growth": 0.08},
        "DistrictB": {"base": 0.5, "growth": 0.00},
        "DistrictC": {"base": 8.0, "growth": 0.03},
    }
    for d_name, params in districts.items():
        for year in years:
            t = year - 2012
            rad = params["base"] * np.exp(params["growth"] * t) + rng.normal(0, 0.02)
            rad = max(rad, 0.001)
            rows.append({
                "district": d_name,
                "year": year,
                "mean_radiance": rad * 1.1,
                "median_radiance": rad,
                "pixel_count": 1000,
                "min_radiance": rad * 0.5,
                "max_radiance": rad * 2.0,
                "std_radiance": rad * 0.3,
            })
    return pd.DataFrame(rows)


# ── Trend Regression ─────────────────────────────────────────────────


class TestTrendRegression:
    """Regression tests for trend fitting on deterministic data."""

    def test_district_trends_match_golden(self, update_golden):
        """Trend statistics should match golden reference."""
        yearly = _make_synthetic_yearly()
        results = []
        for d in sorted(yearly["district"].unique()):
            d_data = yearly[yearly["district"] == d].sort_values("year")
            trend = fit_log_linear_trend(
                d_data["year"].values,
                d_data["median_radiance"].values,
                seed=42,
            )
            trend["district"] = d
            results.append(trend)

        trends_df = pd.DataFrame(results)
        # Drop residuals (array column, not suitable for CSV comparison)
        trends_df = trends_df.drop(columns=["residuals"], errors="ignore")

        golden_name = "trends_synthetic.csv"

        if update_golden:
            _save_golden_csv(trends_df, golden_name)
            pytest.skip("Updated golden file")

        golden = _load_golden_csv(golden_name)
        pd.testing.assert_frame_equal(
            trends_df.reset_index(drop=True),
            golden.reset_index(drop=True),
            atol=0.01,
            check_dtype=False,
        )


# ── Classification Regression ────────────────────────────────────────


class TestClassificationRegression:
    """Regression tests for ALAN classification outputs."""

    def test_classification_matches_golden(self, update_golden):
        """Classification of known radiance values should be stable."""
        test_values = [0.0, 0.5, 0.99, 1.0, 2.5, 4.99, 5.0, 10.0, 50.0, 100.0]
        results = [{"radiance": v, "alan_class": classify_alan(v)} for v in test_values]
        df = pd.DataFrame(results)

        golden_name = "classification_synthetic.csv"

        if update_golden:
            _save_golden_csv(df, golden_name)
            pytest.skip("Updated golden file")

        golden = _load_golden_csv(golden_name)
        pd.testing.assert_frame_equal(
            df.reset_index(drop=True),
            golden.reset_index(drop=True),
            check_dtype=False,
        )


# ── Sky Brightness Regression ────────────────────────────────────────


class TestSkyBrightnessRegression:
    """Regression tests for sky brightness conversion constants."""

    def test_sky_brightness_conversion_matches_golden(self, update_golden):
        """Radiance → magnitude conversion for known inputs."""
        test_radiances = [0.0, 0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 50.0]
        results = []
        for rad in test_radiances:
            mcd = rad * RADIANCE_TO_MCD
            if mcd > 0:
                mag = NATURAL_SKY_BRIGHTNESS - 2.5 * np.log10(1 + mcd / (REFERENCE_MCD * 1e-3))
            else:
                mag = NATURAL_SKY_BRIGHTNESS
            results.append({"radiance_nw": rad, "mcd": round(mcd, 6), "magnitude": round(mag, 4)})

        df = pd.DataFrame(results)
        golden_name = "sky_brightness_synthetic.csv"

        if update_golden:
            _save_golden_csv(df, golden_name)
            pytest.skip("Updated golden file")

        golden = _load_golden_csv(golden_name)
        pd.testing.assert_frame_equal(
            df.reset_index(drop=True),
            golden.reset_index(drop=True),
            atol=0.001,
            check_dtype=False,
        )


# ── District Stats Regression ────────────────────────────────────────


class TestDistrictStatsRegression:
    """Regression tests for synthetic district yearly data."""

    def test_yearly_stats_shape_matches_golden(self, update_golden):
        """Shape and columns of synthetic yearly data should be stable."""
        yearly = _make_synthetic_yearly()
        summary = {
            "n_rows": len(yearly),
            "n_districts": yearly["district"].nunique(),
            "n_years": yearly["year"].nunique(),
            "columns": sorted(yearly.columns.tolist()),
            "min_year": int(yearly["year"].min()),
            "max_year": int(yearly["year"].max()),
        }

        golden_name = "district_stats_synthetic.json"

        if update_golden:
            _save_golden_json(summary, golden_name)
            pytest.skip("Updated golden file")

        golden = _load_golden_json(golden_name)
        assert summary["n_rows"] == golden["n_rows"]
        assert summary["n_districts"] == golden["n_districts"]
        assert summary["n_years"] == golden["n_years"]
        assert summary["columns"] == golden["columns"]
